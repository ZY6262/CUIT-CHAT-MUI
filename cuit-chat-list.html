<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<title></title>
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<link href="css/mui.css" rel="stylesheet" />
		<link href="css/header.css" rel="stylesheet" />
	</head>

		
	<body>
		<div class="mui-content">
			<ul id="chatSnapshotList" class="mui-table-view">
				
			</ul>
		</div>
		
		<script type="text/javascript" src="./js/app.js"></script>
		<script type="text/javascript" src="./js/fastdfs.js"></script>
		<script type="text/javascript" src="./js/myserver.js"></script>
		<script src="js/mui.js"></script>
		<script type="text/javascript">
			
			mui.init();
			mui.plusReady(function () {
	
				/**
				 * 初始化一个ws对象messager用来在App于Server之间推送消息，
				 * 聊天页面也是用这个WS对象以免重复创造。在websocket协议
				 * 连接之前，最好单独采用GET/POST之类的方法做个连接验证。
				 * 但是此处才登录上来久初始化，身份是可信的。
				 * */
				messager.init();
				// 快照渲染
				renderChatSnapshot();
			});
			
			// 渲染快照函数
			function renderChatSnapshot() {
				var mine = app.getUserInfo();
				let chatSnapshotList = app.getChatSnapshot(mine.id);
				var ul_chatSnapshot = document.getElementById('chatSnapshotList');
				var chatSnapshotItemHTML = "";
				ul_chatSnapshot.innerHTML = "";  // 每次渲染此处必须清空一次
				
				chatSnapshotList.forEach(item => {
					// 获取每个friend的数据并渲染到DOM
					let friendUserId = item.friendId;
					let storageFriend = app.getFriendByuserId(friendUserId);
					if (storageFriend != null && storageFriend != undefined) {
						let isRead = item.isRead;
						var badgeHTML = '';
						if (!isRead) 
							badgeHTML = '<span class="mui-badge mui-badge-danger mui-pull-right">' + item.badgeNum + '</span>';
						chatSnapshotItemHTML += '<li friendUserId="' + storageFriend.id + '" friendNickname="' + storageFriend.nickname + '" friendFaceImg="' + storageFriend.faceImg + '" friendFaceImgBig="' + storageFriend.faceImgBig + '" class="mui-table-view-cell mui-media toChat" style="padding: 8px 10px;">' +
												   	'<div class="mui-slider-right mui-disabled">' +
												   		'<a deleteUserId="' + storageFriend.id + '" class="mui-btn mui-btn-red toDelete">删除</a>' +
												   	'</div>' +
												   '<div class="mui-slider-handle mui-media-body ">' +
														badgeHTML +
													   '<img class="mui-media-object mui-pull-left" src="' + fastdfs.IMG_SERVER_ADDR_PORT + storageFriend.faceImg + '"/>' +
														storageFriend.nickname + 
													   '<p class="mui-ellipsis">' + item.record.content + '</p>' +
												   '</div>' +
											   '</li>';
					    ul_chatSnapshot.insertAdjacentHTML('beforeend', chatSnapshotItemHTML);
					}
				});
				
				ul_chatSnapshot.innerHTML = chatSnapshotItemHTML;
				
				// 批量添加打开聊天页面事件监听
				mui('#chatSnapshotList').on('tap', '.toChat', function(e){
					app.chatPageUsePre(this);
				});
				
				// 批量添加删除快照及聊天记录事件监听
				mui('#chatSnapshotList').on('tap', '.toDelete', function(e){
					// 获取朋友ID
					let delId = this.getAttribute('deleteUserId');
					if (!app.isNull(delId)) {
						app.deleteStorageByUserId(delId);
						renderChatSnapshot();  // 渲染快照
						// 若聊天窗口存在则销毁
						plus.webview.close(delId, 'zoom-in', 350, null);
					}
				});
			};
			
			// 消息推送器封装
			window.messager = {
			    socket: null,
			    init: function(){
			        if(window.WebSocket){
						// 如果当前已连接,不需要重新初始化
						if (messager.socket != null 
							&& messager.socket != undefined
							&& messager.socket.readyState == WebSocket.OPEN){
									return false;
						}
			            messager.socket = new WebSocket(myserver.WS_SERVER_IP_PORT);
						messager.socket.onopen = messager.wsopen;
			            messager.socket.onerror = messager.wserror;
			            messager.socket.onclose = messager.wsclose;
						messager.socket.onmessage = messager.wsmessage;
			        } else {
			            mui.toast('请升级浏览器引擎...');
			        }
			    },
				keepAlive: function(){
					// 心跳任务，顺带执行拉取未签收消息(防止网络延迟导致的丢包)
					let mesageModel = new app.MessageModel(app.MSG_TYPE_ENUM.KEEPALIVE_MSG, null, null);
					messager.wschat(JSON.stringify(mesageModel));	
					messager.fetMsgsAndRender();
				},
				wschat: function(msg){
					// 发送的时候要考虑服务器状态
					if (messager.socket != null
						&& messager.socket != undefined
						&& messager.socket.readyState == WebSocket.OPEN){
							messager.socket.send(msg);  // 服务器与客户端连接正常
							renderChatSnapshot();
					} else {  // 服务端与客户端连接异常，需要重新连接
						messager.init();
						setTimeout(function(){  // 因为init方法与wsRechat异步的，所以timeout一秒
							messager.wsReChat(msg);
						}, 1000);
					}
					
				},
				wsReChat: function(msg){  // 重新发送消息
					console.log('消息重新发送中');
					messager.socket.send(msg);
					renderChatSnapshot();
				},
				wsopen: function(){
					console.log("连接建立成功...");
					let user = app.getUserInfo();
					let chatMsg = new app.ChatMsgModel(user.id, null, null);
					let msgModel = new app.MessageModel(app.MSG_TYPE_ENUM.CONNECT_MSG, chatMsg, null);
					// 立即回发连接消息，方便Ws服务器记忆
					messager.wschat(JSON.stringify(msgModel));
					
					// 拉取未签收消息
					messager.fetMsgsAndRender();
					
					// 设置定时消息，每30s发送执行一次心跳任务
					setInterval(function(){
						messager.keepAlive();
					}, 30000);
				},
				fetMsgsAndRender: function(){
					let unSignedMsgList = myserver.fetchUnSignedMsgList();
					console.log(unSignedMsgList.length);
					var msgIds;  // 回发服务端签收消息
					if (!app.isNull(unSignedMsgList) && unSignedMsgList.length > 0) {
						unSignedMsgList.forEach(item => {
							// 逐条保存消息
							app.saveChatMsg(item.chatMsgModel.receiveId, item.chatMsgModel.senderId, item.chatMsgModel, app.MSG_SENDER_ENUM.FRIEND);
							// 逐条保存快照
							app.saveChatSnapshot(item.chatMsgModel.receiveId, item.chatMsgModel.senderId, item.chatMsgModel, false);
							msgIds += (item.chatMsgModel.msgId + ',');
						});
						
						// 回发签收消息,此处跳过wsChat方法，直接调用send方法防止重复渲染快照
						if (!app.isNull(msgIds)){
							let signMsgModel = new app.MessageModel(app.MSG_TYPE_ENUM.SIGNED_MSG, null, msgIds);
							messager.socket.send(JSON.stringify(signMsgModel));
						}
							
						// 渲染快照
						renderChatSnapshot();
					}
				},
			    wsmessage: function( e ){
					let newMsg = JSON.parse(e.data);
					if (newMsg.actionName == app.MSG_TYPE_ENUM.SYSTEM_PULL_FRIENDS_MSG) {
						// 系统重新拉取好友列表
						let contactPage = plus.webview.getWebviewById('cuit-chat-contact.html');
						contactPage.evalJS('rePullFriends()');
					} else if (newMsg.actionName == app.MSG_TYPE_ENUM.CHAT_MSG) {
						// 好友聊天页面渲染，回发消息签收消息
						let friendPage = plus.webview.getWebviewById(newMsg.chatMsgModel.senderId);
						let msg = JSON.stringify(newMsg.chatMsgModel);
						var isRead = true;
						if (friendPage != null && friendPage != undefined) {
							friendPage.evalJS("receiveMsg('" + msg + "')");
							// 判断当前显示的webview是否是指定的webview
							let stackTopPage = plus.webview.getTopWebview();  // 获取应用显示页栈顶的webview
							if (stackTopPage.id != friendPage.id)
								isRead = false;
						} else {
							// 与该好友聊天的页面未创建，应该处理到'cuit-chat-list.html'的li标签中
							isRead = false;
						}
						// 保存聊天消息
						let myId = newMsg.chatMsgModel.receiveId;
						let friendUserId = newMsg.chatMsgModel.senderId;
						let record = newMsg.chatMsgModel;
						app.saveChatMsg(myId, friendUserId, record, app.MSG_SENDER_ENUM.FRIEND);
						// 保存聊天快照
						app.saveChatSnapshot(myId, friendUserId, record, isRead);
						// 刷新快照的显示
						renderChatSnapshot();
						
						// 回发客户端签收消息
						let signMsgModel = new app.MessageModel(app.MSG_TYPE_ENUM.SIGNED_MSG, null, newMsg.chatMsgModel.msgId);
						messager.wschat(JSON.stringify(signMsgModel));
					} else if (newMsg.actionName == app.MSG_TYPE_ENUM.KEEPALIVE_MSG) {
						// 心跳消息
					}
			    },
				wserror: function(){
					console.log("连接出错...");
				},
				wsclose: function(){
					console.log("连接已关闭...");
				},
			};
		</script>
	</body>

</html>
